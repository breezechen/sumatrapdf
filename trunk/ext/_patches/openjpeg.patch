diff -rPu5 openjpeg.orig\j2k.c openjpeg\j2k.c
--- openjpeg.orig\j2k.c	Tue Apr 22 09:54:20 2014
+++ openjpeg\j2k.c	Thu May 15 17:21:06 2014
@@ -3174,10 +3174,15 @@
 
         if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {
                 opj_event_msg(p_manager, EVT_ERROR, "Error reading POC marker\n");
                 return OPJ_FALSE;
         }
+        /* cf. https://code.google.com/p/openjpeg/issues/detail?id=165 */
+        if (l_current_poc_nb >= sizeof(l_tcp->pocs) / sizeof(l_tcp->pocs[0])) {
+                opj_event_msg(p_manager, EVT_ERROR, "Too many POC entries (%d > 32)\n", l_current_poc_nb);
+                return OPJ_FALSE;
+        }
 
         l_cp = &(p_j2k->m_cp);
         l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
                                 &l_cp->tcps[p_j2k->m_current_tile_number] :
                                 p_j2k->m_specific_param.m_decoder.m_default_tcp;
@@ -4078,10 +4083,12 @@
                 opj_read_bytes(p_header_data,&l_current_part ,1);       /* TPsot */
                 ++p_header_data;
 
                 opj_read_bytes(p_header_data,&l_num_parts ,1);          /* TNsot */
                 ++p_header_data;
+                /* cf. https://code.google.com/p/openjpeg/issues/detail?id=254 */
+                l_num_parts++;
 
                 if (l_num_parts != 0) { /* Number of tile-part header is provided by this tile-part header */
                         /* Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of
                          * tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002). */
                         if (l_tcp->m_nb_tile_parts) {
@@ -4090,10 +4097,13 @@
                                                         "number of tile-part (%d), giving up\n", l_current_part, l_tcp->m_nb_tile_parts );
                                         p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
                                         return OPJ_FALSE;
                                 }
                         }
+                        if (l_num_parts < l_tcp->m_nb_tile_parts) {
+                                l_num_parts = l_tcp->m_nb_tile_parts;
+                        }
                         if( l_current_part >= l_num_parts ) {
                           /* testcase 451.pdf.SIGSEGV.ce9.3723 */
                           opj_event_msg(p_manager, EVT_ERROR, "In SOT marker, TPSot (%d) is not valid regards to the current "
                             "number of tile-part (header) (%d), giving up\n", l_current_part, l_num_parts );
                           p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
@@ -4334,10 +4344,16 @@
         l_current_data = &(l_tcp->m_data);
         l_tile_len = &l_tcp->m_data_size;
 
         /* Patch to support new PHR data */
         if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
+            /* cf. https://code.google.com/p/sumatrapdf/issues/detail?id=2591 */
+            if (p_j2k->m_specific_param.m_decoder.m_sot_length > opj_stream_get_number_byte_left(p_stream)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough data to decode tile\n");
+                return OPJ_FALSE;
+            }
+
             if (! *l_current_data) {
                 /* LH: oddly enough, in this path, l_tile_len!=0.
                  * TODO: If this was consistant, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).
                  */
                 *l_current_data = (OPJ_BYTE*) opj_malloc(p_j2k->m_specific_param.m_decoder.m_sot_length);
diff -rPu5 openjpeg.orig\jp2.c openjpeg\jp2.c
--- openjpeg.orig\jp2.c	Tue Apr 22 09:54:20 2014
+++ openjpeg\jp2.c	Thu May 15 16:55:49 2014
@@ -1095,10 +1095,12 @@
     {
     /* WATCH: acn = asoc - 1 ! */
     asoc = info[i].asoc;
     if(asoc == 0 || asoc == 65535)
       {
+        if (asoc == 0 && i < image->numcomps)
+            image->comps[i].alpha = info[i].typ;
       continue;
       }
 
     cn = info[i].cn; 
     acn = (OPJ_UINT16)(asoc - 1);
@@ -1118,10 +1120,11 @@
 
 			info[i].asoc = (OPJ_UINT16)(cn + 1);
 			info[acn].asoc = (OPJ_UINT16)(info[acn].cn + 1);
 		}
 
+		image->comps[cn].alpha = info[i].typ;
 	}
 
 	if(color->jp2_cdef->info) opj_free(color->jp2_cdef->info);
 
 	opj_free(color->jp2_cdef); color->jp2_cdef = NULL;
@@ -1303,10 +1306,12 @@
 		    p_image->color_space = OPJ_CLRSPC_SRGB;
 	    else if (jp2->enumcs == 17)
 		    p_image->color_space = OPJ_CLRSPC_GRAY;
 	    else if (jp2->enumcs == 18)
 		    p_image->color_space = OPJ_CLRSPC_SYCC;
+        else if (jp2->enumcs == 24)
+                p_image->color_space = OPJ_CLRSPC_EYCC;
 	    else
 		    p_image->color_space = OPJ_CLRSPC_UNKNOWN;
 
 	    /* Apply the color space if needed */
 	    if(jp2->color.jp2_cdef) {
diff -rPu5 openjpeg.orig\openjpeg.h openjpeg\openjpeg.h
--- openjpeg.orig\openjpeg.h	Tue Apr 22 09:54:20 2014
+++ openjpeg\openjpeg.h	Thu May 15 15:45:04 2014
@@ -217,11 +217,12 @@
 typedef enum COLOR_SPACE {
 	OPJ_CLRSPC_UNKNOWN = -1,	/**< not supported by the library */
 	OPJ_CLRSPC_UNSPECIFIED = 0,	/**< not specified in the codestream */ 
 	OPJ_CLRSPC_SRGB = 1,		/**< sRGB */
 	OPJ_CLRSPC_GRAY = 2,		/**< grayscale */
-	OPJ_CLRSPC_SYCC = 3		/**< YUV */
+	OPJ_CLRSPC_SYCC = 3,		/**< YUV */
+        OPJ_CLRSPC_EYCC = 4		/**< e-YCC */
 } OPJ_COLOR_SPACE;
 
 /**
  * Supported codec
 */
@@ -559,10 +560,12 @@
 	OPJ_UINT32 resno_decoded;
 	/** number of division by 2 of the out image compared to the original size of image */
 	OPJ_UINT32 factor;
 	/** image component data */
 	OPJ_INT32 *data;
+        /** alpha channel */
+        OPJ_UINT16 alpha;
 } opj_image_comp_t;
 
 /** 
  * Defines image data and characteristics
  * */
diff -rPu5 openjpeg.orig\opj_config.h openjpeg\opj_config.h
--- openjpeg.orig\opj_config.h	Thu Jan 01 01:00:00 1970
+++ openjpeg\opj_config.h	Sun May 19 03:54:43 2013
@@ -0,0 +1 @@
+// #define OPJ_HAVE_STDINT_H
diff -rPu5 openjpeg.orig\opj_config_private.h openjpeg\opj_config_private.h
--- openjpeg.orig\opj_config_private.h	Thu Jan 01 01:00:00 1970
+++ openjpeg\opj_config_private.h	Thu May 15 15:45:40 2014
@@ -0,0 +1,9 @@
+#define OPJ_PACKAGE_VERSION "2.0.1"
+
+// #define OPJ_HAVE_INTTYPES_H
+// #define OPJ_HAVE_FSEEKO
+
+#define OPJ_STATIC
+#define OPJ_EXPORTS
+
+#define USE_JPIP
diff -rPu5 openjpeg.orig\opj_malloc.h openjpeg\opj_malloc.h
--- openjpeg.orig\opj_malloc.h	Tue Apr 22 09:54:20 2014
+++ openjpeg\opj_malloc.h	Thu May 15 15:47:34 2014
@@ -53,11 +53,11 @@
 #ifdef ALLOC_PERF_OPT
 void * OPJ_CALLCONV opj_malloc(size_t size);
 #else
 /* prevent assertion on overflow for MSVC */
 #ifdef _MSC_VER
-#define opj_malloc(size) ((size_t)(size) >= (size_t)-0x100 ? NULL : malloc(size))
+#define opj_malloc(size) ((size_t)(size) >= 0x7ffdefff ? NULL : malloc(size))
 #else
 #define opj_malloc(size) malloc(size)
 #endif
 #endif
 
@@ -70,11 +70,11 @@
 #ifdef ALLOC_PERF_OPT
 void * OPJ_CALLCONV opj_calloc(size_t _NumOfElements, size_t _SizeOfElements);
 #else
 /* prevent assertion on overflow for MSVC */
 #ifdef _MSC_VER
-#define opj_calloc(num, size) ((size_t)(num) != 0 && (size_t)(num) >= (size_t)-0x100 / (size_t)(size) ? NULL : calloc(num, size))
+#define opj_calloc(num, size) ((size_t)(num) != 0 && (size_t)(num) >= 0x7ffdefff / (size_t)(size) ? NULL : calloc(num, size))
 #else
 #define opj_calloc(num, size) calloc(num, size)
 #endif
 #endif
 
@@ -154,11 +154,11 @@
 #ifdef ALLOC_PERF_OPT
 void * OPJ_CALLCONV opj_realloc(void * m, size_t s);
 #else
 /* prevent assertion on overflow for MSVC */
 #ifdef _MSC_VER
-#define opj_realloc(m, s) ((size_t)(s) >= (size_t)-0x100 ? NULL : realloc(m, s))
+#define opj_realloc(m, s) ((size_t)(s) >= 0x7ffdefff ? NULL : realloc(m, s))
 #else
 #define opj_realloc(m, s) realloc(m, s)
 #endif
 #endif
 
diff -rPu5 openjpeg.orig\t2.c openjpeg\t2.c
--- openjpeg.orig\t2.c	Tue Apr 22 09:54:20 2014
+++ openjpeg\t2.c	Thu May 15 16:38:14 2014
@@ -861,14 +861,13 @@
         /* SOP markers */
 
         if (p_tcp->csty & J2K_CP_CSTY_SOP) {
                 if (p_max_length < 6) {
                         /* TODO opj_event_msg(p_t2->cinfo->event_mgr, EVT_WARNING, "Not enough space for expected SOP marker\n"); */
-                        printf("Not enough space for expected SOP marker\n");
+                        fprintf(stderr, "Not enough space for expected SOP marker\n");
                 } else if ((*l_current_data) != 0xff || (*(l_current_data + 1) != 0x91)) {
                         /* TODO opj_event_msg(p_t2->cinfo->event_mgr, EVT_WARNING, "Expected SOP marker\n"); */
-                        printf("Expected SOP marker\n");
                         fprintf(stderr, "Error : expected SOP marker\n");
                 } else {
                         l_current_data += 6;
                 }
 
@@ -1015,10 +1014,15 @@
 
                         do {
                                 l_cblk->segs[l_segno].numnewpasses = (OPJ_UINT32)opj_int_min((OPJ_INT32)(l_cblk->segs[l_segno].maxpasses - l_cblk->segs[l_segno].numpasses), n);
                                 l_cblk->segs[l_segno].newlen = opj_bio_read(l_bio, l_cblk->numlenbits + opj_uint_floorlog2(l_cblk->segs[l_segno].numnewpasses));
                                         JAS_FPRINTF(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n", l_included, l_cblk->segs[l_segno].numnewpasses, l_increment, l_cblk->segs[l_segno].newlen );
+                                /* testcase 1802.pdf.SIGSEGV.36e.894 */
+                                if (l_cblk->segs[l_segno].newlen > *l_modified_length_ptr) {
+                                        opj_bio_destroy(l_bio);
+                                        return OPJ_FALSE;
+                                }
 
                                 n -= (OPJ_INT32)l_cblk->segs[l_segno].numnewpasses;
                                 if (n > 0) {
                                         ++l_segno;
 
@@ -1157,10 +1161,11 @@
                                 /* Check if the cblk->data have allocated enough memory */
                                 if ((l_cblk->data_current_size + l_seg->newlen) > l_cblk->data_max_size) {
                                     OPJ_BYTE* new_cblk_data = (OPJ_BYTE*) opj_realloc(l_cblk->data, l_cblk->data_current_size + l_seg->newlen);
                                     if(! new_cblk_data) {
                                         opj_free(l_cblk->data);
+                                        l_cblk->data = NULL;
                                         l_cblk->data_max_size = 0;
                                         /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to realloc code block cata!\n"); */
                                         return OPJ_FALSE;
                                     }
                                     l_cblk->data_max_size = l_cblk->data_current_size + l_seg->newlen;
