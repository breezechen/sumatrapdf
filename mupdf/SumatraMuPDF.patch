diff -r 27dbba5ea9e6 fitz/dev_draw.c
--- a/fitz/dev_draw.c	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/dev_draw.c	Sat May 01 23:42:01 2010 +0200
@@ -828,27 +828,28 @@ fz_drawfreeuser(void *user)
 	fz_freeael(dev->ael);
 	fz_free(dev);
 }
 
 fz_device *
 fz_newdrawdevice(fz_glyphcache *cache, fz_pixmap *dest)
 {
 	fz_drawdevice *ddev = fz_malloc(sizeof(fz_drawdevice));
+	fz_device *dev;
 	if (dest->colorspace)
 		ddev->model = fz_keepcolorspace(dest->colorspace);
 	else
 		ddev->model = nil;
 	ddev->cache = cache;
 	ddev->gel = fz_newgel();
 	ddev->ael = fz_newael();
 	ddev->dest = dest;
 	ddev->cliptop = 0;
 
-	fz_device *dev = fz_newdevice(ddev);
+	dev = fz_newdevice(ddev);
 	dev->freeuser = fz_drawfreeuser;
 
 	dev->fillpath = fz_drawfillpath;
 	dev->strokepath = fz_drawstrokepath;
 	dev->clippath = fz_drawclippath;
 	dev->clipstrokepath = fz_drawclipstrokepath;
 
 	dev->filltext = fz_drawfilltext;
diff -r 27dbba5ea9e6 fitz/dev_text.c
--- a/fitz/dev_text.c	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/dev_text.c	Sat May 01 23:42:01 2010 +0200
@@ -222,40 +222,178 @@ fz_textextractspan(fz_textspan **last, f
 
 		rect.x0 = 0.0;
 		rect.y0 = 0.0;
 		rect.x1 = adv;
 		rect.y1 = 1.0;
 		rect = fz_transformrect(trm, rect);
 
 		/* Add to the text span */
-		if (fabs(dy) > 0.001)
+		/* if (fabs(dy) > 0.001) */ if (fabs(dy) > 0.27) /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=687 */
 		{
 			fz_addtextnewline(last, font, size);
 		}
-		else if (fabs(dx) > 0.2)
+		else if (fabs(dx) > 0.15 && (*last)->len > 0 && (*last)->text[(*last)->len - 1].c != ' ') /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=687 */
 		{
 			fz_rect spacerect;
 			spacerect.x0 = -fabs(dx);
 			spacerect.y0 = 0.0;
 			spacerect.x1 = 0.0;
 			spacerect.y1 = 1.0;
 			spacerect = fz_transformrect(trm, spacerect);
 			fz_addtextchar(last, font, size, ' ', fz_roundrect(spacerect));
 		}
-		fz_addtextchar(last, font, size, text->els[i].ucs, fz_roundrect(rect));
+		/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=788 */
+		/* add one or several characters */
+		for (fterr = 1; fterr <= text->els[i].ucs[0]; fterr++)
+			fz_addtextchar(last, font, size, text->els[i].ucs[fterr], fz_roundrect(rect));
 	}
 }
 
+/***** various string fixups *****/
+static void
+ensurespanlength(fz_textspan *span, int mincap)
+{
+	if (span->cap < mincap)
+	{
+		span->cap = mincap * 3 / 2;
+		span->text = fz_realloc(span->text, span->cap * sizeof(fz_textchar));
+	}
+}
+
+static void
+insertcharacter(fz_textspan *span, int i, int c)
+{
+	ensurespanlength(span, span->len + 1);
+	memmove(&span->text[i + 1], &span->text[i], (span->len - i) * sizeof(fz_textchar));
+	span->len++;
+	span->text[i].c = c;
+	span->text[i].bbox = span->text[i + 1].bbox;
+}
+
+static void
+mergetwospans(fz_textspan *span)
+{
+	ensurespanlength(span, span->len + span->next->len);
+	memcpy(&span->text[span->len], &span->next->text[0], span->next->len * sizeof(fz_textchar));
+	span->len += span->next->len;
+	span->next->len = 0;
+}
+
+static void
+deletecharacter(fz_textspan *span, int i)
+{
+	memmove(&span->text[i], &span->text[i + 1], (span->len - (i + 1)) * sizeof(fz_textchar));
+	span->len--;
+}
+
+static void
+reversecharacters(fz_textspan *span, int i, int j)
+{
+	while (i < j)
+	{
+		fz_textchar tc = span->text[i];
+		span->text[i] = span->text[j];
+		span->text[j] = tc;
+		i++; j--;
+	}
+}
+
+static int
+ornatecharacter(int ornate, int character)
+{
+	static wchar_t *ornates[] = {
+		L" \xA8\xB4`^",
+		L"a\xE4\xE1\xE0\xE2", L"A\xC4\xC1\xC0\xC2",
+		L"e\xEB\xE9\xE8\xEA", L"E\xCB\xC9\xC8\xCA",
+		L"i\xEF\xED\xEC\xEE", L"I\xCF\xCD\xCC\xCE",
+		L"o\xF6\xF3\xF2\xF4", L"O\xD6\xD3\xD2\xD4",
+		L"u\xFC\xFA\xF9\xFB", L"U\xDC\xDA\xD9\xDB",
+		nil
+	};
+	int i, j;
+
+	for (i = 1; ornates[0][i] && ornates[0][i] != (wchar_t)ornate; i++);
+	for (j = 1; ornates[j] && ornates[j][0] != (wchar_t)character; j++);
+	return ornates[0][i] && ornates[j] ? ornates[j][i] : 0;
+}
+
+/* TODO: Complete these lists... */
+#define ISLEFTTORIGHTCHAR(c) ((0x0041 <= (c) && (c) <= 0x005A) || (0x0061 <= (c) && (c) <= 0x007A) || (0xFB00 <= (c) && (c) <= 0xFB06))
+#define ISRIGHTTOLEFTCHAR(c) ((0x0590 <= (c) && (c) <= 0x05FF) || (0x0600 <= (c) && (c) <= 0x06FF) || (0x0750 <= (c) && (c) <= 0x077F) || (0xFB50 <= (c) && (c) <= 0xFDFF) || (0xFE70 <= (c) && (c) <= 0xFEFF))
+
+static void
+fixuptextspans(fz_textspan *span)
+{
+	for (; span; span = span->next)
+	{
+		int i;
+		for (i = 0; i < span->len; i++)
+		{
+			switch (span->text[i].c)
+			{
+			/* recombine characters and their accents */
+			case 0x00A8: /* ¨ */
+			case 0x00B4: /* ´ */
+			case 0x0060: /* ` */
+			case 0x005E: /* ^ */
+				if (i + 1 == span->len && span->next && span->next->len > 1 && span->next->text[0].c == 32)
+				{
+					mergetwospans(span);
+				}
+				if (i + 2 < span->len && span->text[i + 1].c == 32)
+				{
+					int newC = ornatecharacter(span->text[i].c, span->text[i + 2].c);
+					if (newC)
+					{
+						deletecharacter(span, i);
+						deletecharacter(span, i);
+						span->text[i].c = newC;
+					}
+				}
+				break;
+			/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=400 */
+			/* copy ligatures as individual characters */
+			case 0xFB00: /* ff */
+				insertcharacter(span, i++, 'f'); span->text[i].c = 'f'; break;
+			case 0xFB03: /* ffi */
+				insertcharacter(span, i++, 'f');
+			case 0xFB01: /* fi */
+				insertcharacter(span, i++, 'f'); span->text[i].c = 'i'; break;
+			case 0xFB04: /* ffl */
+				insertcharacter(span, i++, 'f');
+			case 0xFB02: /* fl */
+				insertcharacter(span, i++, 'f'); span->text[i].c = 'l'; break;
+			case 0xFB05: case 0xFB06: /* st */
+				insertcharacter(span, i++, 's'); span->text[i].c = 't'; break;
+			default:
+				/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=733 */
+				/* reverse words written in RTL languages */
+				if (ISRIGHTTOLEFTCHAR(span->text[i].c))
+				{
+					int j = i + 1;
+					while (j < span->len && span->text[j - 1].bbox.x0 <= span->text[j].bbox.x0 && !ISLEFTTORIGHTCHAR(span->text[i].c))
+						j++;
+					reversecharacters(span, i, j - 1);
+					i = j;
+				}
+			}
+		}
+	}
+}
+/***** various string fixups *****/
+
 static void
 fz_textfilltext(void *user, fz_text *text, fz_matrix ctm,
 	fz_colorspace *colorspace, float *color, float alpha)
 {
 	fz_textdevice *tdev = user;
+	fz_textspan *firstSpan = tdev->span;
 	fz_textextractspan(&tdev->span, text, ctm, &tdev->point);
+	fixuptextspans(firstSpan);
 }
 
 static void
 fz_textignoretext(void *user, fz_text *text, fz_matrix ctm)
 {
 	fz_textdevice *tdev = user;
 	fz_textextractspan(&tdev->span, text, ctm, &tdev->point);
 }
@@ -266,19 +404,20 @@ fz_textfreeuser(void *user)
 	fz_textdevice *tdev = user;
 	tdev->span->eol = 1;
 	fz_free(tdev);
 }
 
 fz_device *
 fz_newtextdevice(fz_textspan *root)
 {
+	fz_device *dev;
 	fz_textdevice *tdev = fz_malloc(sizeof(fz_textdevice));
 	tdev->span = root;
 	tdev->point.x = -1;
 	tdev->point.y = -1;
 
-	fz_device *dev = fz_newdevice(tdev);
+	dev = fz_newdevice(tdev);
 	dev->freeuser = fz_textfreeuser;
 	dev->filltext = fz_textfilltext;
 	dev->ignoretext = fz_textignoretext;
 	return dev;
 }
diff -r 27dbba5ea9e6 fitz/filt_flate.c
--- a/fitz/filt_flate.c	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/filt_flate.c	Sat May 01 23:42:01 2010 +0200
@@ -89,16 +89,21 @@ fz_processflated(fz_filter *f, fz_buffer
 	zp->next_out = out->wp;
 	zp->avail_out = out->ep - out->wp;
 
 	err = inflate(zp, Z_NO_FLUSH);
 
 	/* Make sure we call it with Z_FINISH at the end of input */
 	if (err == Z_OK && in->eof && zp->avail_in == 0 && zp->avail_out > 0)
 		err = inflate(zp, Z_FINISH);
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=590 */
+	/* Ignore data check errors at EOS */
+	else if (err == Z_DATA_ERROR && in->eof && zp->avail_in == 0 &&
+		zp->avail_out > 0 && !strcmp(zp->msg, "incorrect data check"))
+		err = Z_BUF_ERROR;
 
 	in->rp = in->wp - zp->avail_in;
 	out->wp = out->ep - zp->avail_out;
 
 	if (err == Z_STREAM_END || err == Z_BUF_ERROR)
 	{
 		return fz_iodone;
 	}
diff -r 27dbba5ea9e6 fitz/fitz_base.h
--- a/fitz/fitz_base.h	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/fitz_base.h	Sat May 01 23:42:01 2010 +0200
@@ -1,15 +1,21 @@
 /*
  * Include the basic standard libc headers.
  */
 
 #ifndef _FITZ_BASE_H_
 #define _FITZ_BASE_H_
 
+#ifdef _DEBUG
+#define _CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
 #include <assert.h>
 #include <stdarg.h>
 
 #include <limits.h>	/* INT_MIN, MAX ... */
diff -r 27dbba5ea9e6 fitz/fitz_res.h
--- a/fitz/fitz_res.h	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/fitz_res.h	Sat May 01 23:42:01 2010 +0200
@@ -250,29 +250,29 @@ void fz_debugpath(fz_path *, int indent)
  */
 
 typedef struct fz_textel_s fz_textel;
 
 struct fz_textel_s
 {
 	float x, y;
 	int gid;
-	int ucs;
+	int ucs[8]; /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=788 */
 };
 
 struct fz_text_s
 {
 	fz_font *font;
 	fz_matrix trm;
 	int len, cap;
 	fz_textel *els;
 };
 
 fz_text * fz_newtext(fz_font *face);
-void fz_addtext(fz_text *text, int gid, int ucs, float x, float y);
+void fz_addtext(fz_text *text, int gid, int ucs[], float x, float y);
 void fz_endtext(fz_text *text);
 void fz_freetext(fz_text *text);
 void fz_debugtext(fz_text*, int indent);
 fz_rect fz_boundtext(fz_text *text, fz_matrix ctm);
 fz_text *fz_clonetext(fz_text *old);
 
 /*
  * Colorspace resources.
diff -r 27dbba5ea9e6 fitz/res_font.c
--- a/fitz/res_font.c	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/res_font.c	Sat May 01 23:42:01 2010 +0200
@@ -52,17 +52,17 @@ fz_dropfont(fz_font *font)
 	if (font && --font->refs == 0)
 	{
 		if (font->t3procs)
 		{
 			if (font->t3resources)
 				fz_dropobj(font->t3resources);
 			for (i = 0; i < 256; i++)
 				if (font->t3procs[i])
-					fz_dropbuffer(font->t3procs[i]);
+			fz_dropbuffer(font->t3procs[i]);
 			fz_free(font->t3procs);
 			fz_free(font->t3widths);
 		}
 
 		if (font->ftface)
 		{
 			fterr = FT_Done_Face((FT_Face)font->ftface);
 			if (fterr)
diff -r 27dbba5ea9e6 fitz/res_text.c
--- a/fitz/res_text.c	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/res_text.c	Sat May 01 23:42:01 2010 +0200
@@ -94,20 +94,24 @@ fz_growtext(fz_text *text, int n)
 	if (text->len + n < text->cap)
 		return;
 	while (text->len + n > text->cap)
 		text->cap = text->cap + 36;
 	text->els = fz_realloc(text->els, sizeof (fz_textel) * text->cap);
 }
 
 void
-fz_addtext(fz_text *text, int gid, int ucs, float x, float y)
+fz_addtext(fz_text *text, int gid, int ucs[], float x, float y)
 {
 	fz_growtext(text, 1);
-	text->els[text->len].ucs = ucs;
+	{ /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=788 */
+		int i;
+		for (i = 0; i <= ucs[0]; i++)
+			text->els[text->len].ucs[i] = ucs[i];
+	}
 	text->els[text->len].gid = gid;
 	text->els[text->len].x = x;
 	text->els[text->len].y = y;
 	text->len++;
 }
 
 void fz_debugtext(fz_text *text, int indent)
 {
diff -r 27dbba5ea9e6 fitz/stm_open.c
--- a/fitz/stm_open.c	Sat May 01 14:31:12 2010 +0200
+++ b/fitz/stm_open.c	Sat May 01 23:42:01 2010 +0200
@@ -56,16 +56,50 @@ fz_dropstream(fz_stream *stm)
 			break;
 		}
 
 		fz_dropbuffer(stm->buffer);
 		fz_free(stm);
 	}
 }
 
+#ifdef WIN32
+#include <windows.h>
+
+static int open_utf8(char *utf8path, int oflag, int pmode)
+{
+	int pathlen = strlen(utf8path) + 1;
+	wchar_t *wpath = fz_malloc(pathlen * 2);
+	int result;
+
+	/* Convert UTF-8 to UTF-16 */
+	result = MultiByteToWideChar(CP_UTF8, 0, utf8path, -1, wpath, pathlen * 2);
+	/* (and if the path isn't UTF-8 after all, fall back to the ANSI code page) */
+	if (result == ERROR_NO_UNICODE_TRANSLATION)
+		MultiByteToWideChar(CP_ACP, 0, utf8path, -1, wpath, pathlen * 2);
+#ifdef _UNICODE
+	result = _wopen(wpath, oflag, pmode);
+#else
+	{
+		/* Convert UTF-16 to the ANSI code page */
+		char *path = fz_malloc(pathlen);
+		WideCharToMultiByte(CP_ACP, 0, wpath, -1, path, pathlen, NULL, NULL);
+		result = open(path, oflag, pmode);
+		fz_free(path);
+	}
+#endif
+	fz_free(wpath);
+
+	return result;
+}
+
+/* redefine open(...) below, as the path is supposed to be UTF-8 */
+#define open(path, oflag, pmode) open_utf8(path, oflag, pmode);
+#endif
+
 fz_error fz_openrfile(fz_stream **stmp, char *path)
 {
 	fz_stream *stm;
 
 	stm = newstm(FZ_SFILE);
 
 	stm->buffer = fz_newbuffer(FZ_BUFSIZE);
 
diff -r 27dbba5ea9e6 mupdf/mupdf.h
--- a/mupdf/mupdf.h	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/mupdf.h	Sat May 01 23:42:01 2010 +0200
@@ -484,16 +484,17 @@ typedef struct pdf_link_s pdf_link;
 typedef struct pdf_comment_s pdf_comment;
 typedef struct pdf_widget_s pdf_widget;
 typedef struct pdf_outline_s pdf_outline;
 
 typedef enum pdf_linkkind_e
 {
 	PDF_LGOTO = 0,
 	PDF_LURI,
+	PDF_LLAUNCH /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=726 */
 } pdf_linkkind;
 
 struct pdf_link_s
 {
 	pdf_linkkind kind;
 	fz_rect rect;
 	fz_obj *dest;
 	pdf_link *next;
diff -r 27dbba5ea9e6 mupdf/pdf_annot.c
--- a/mupdf/pdf_annot.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_annot.c	Sat May 01 23:42:01 2010 +0200
@@ -10,16 +10,18 @@ pdf_newlink(pdf_linkkind kind, fz_rect b
 	link->dest = fz_keepobj(dest);
 	link->next = nil;
 	return link;
 }
 
 void
 pdf_droplink(pdf_link *link)
 {
+	if (!link)
+		return;
 	if (link->next)
 		pdf_droplink(link->next);
 	if (link->dest)
 		fz_dropobj(link->dest);
 	fz_free(link);
 }
 
 static fz_obj *
@@ -91,16 +93,23 @@ pdf_loadlink(pdf_xref *xref, fz_obj *dic
 			pdf_logpage("action goto (%d %d R)\n", fz_tonum(dest), fz_togen(dest));
 		}
 		else if (fz_isname(obj) && !strcmp(fz_toname(obj), "URI"))
 		{
 			kind = PDF_LURI;
 			dest = fz_dictgets(action, "URI");
 			pdf_logpage("action uri %s\n", fz_tostrbuf(dest));
 		}
+		/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=726 */
+		else if (fz_isname(obj) && !strcmp(fz_toname(obj), "Launch"))
+		{
+			kind = PDF_LLAUNCH;
+			dest = fz_dictgets(action, "F");
+			pdf_logpage("action launch (%d %d R)\n", fz_tonum(dest), fz_togen(dest));
+		}
 		else
 		{
 			pdf_logpage("unhandled link action, ignoring link\n");
 			dest = nil;
 		}
 	}
 
 	pdf_logpage("}\n");
diff -r 27dbba5ea9e6 mupdf/pdf_build.c
--- a/mupdf/pdf_build.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_build.c	Sat May 01 23:42:01 2010 +0200
@@ -1,10 +1,12 @@
 #include "fitz.h"
 #include "mupdf.h"
+#include <ft2build.h>
+#include FT_FREETYPE_H
 
 void
 pdf_initgstate(pdf_gstate *gs, fz_matrix ctm)
 {
 	gs->ctm = ctm;
 	gs->clipdepth = 0;
 
 	gs->strokestate.linewidth = 1.0;
@@ -229,16 +231,17 @@ pdf_showpattern(pdf_csi *csi, pdf_patter
 	x1 = ceil(bbox.x1 / pat->xstep);
 	y1 = ceil(bbox.y1 / pat->ystep);
 
 	oldtopctm = csi->topctm;
 	oldtop = csi->gtop;
 
 	for (y = y0; y < y1; y++)
 	{
+
 		for (x = x0; x < x1; x++)
 		{
 			gstate->ctm = fz_concat(fz_translate(x * pat->xstep, y * pat->ystep), ptm);
 			csi->topctm = gstate->ctm;
 			error = pdf_runcsibuffer(csi, pat->resources, pat->contents);
 			if (error)
 				fz_catch(error, "cannot render pattern tile");
 			while (oldtop < csi->gtop)
@@ -528,33 +531,50 @@ pdf_showglyph(pdf_csi *csi, int cid)
 {
 	pdf_gstate *gstate = csi->gstate + csi->gtop;
 	pdf_fontdesc *fontdesc = gstate->font;
 	fz_matrix tsm, trm;
 	float w0, w1, tx, ty;
 	pdf_hmtx h;
 	pdf_vmtx v;
 	int gid;
-	int ucs;
+	int ucs[8] = { 1, -1 }; /* len, characters... */
 
 	tsm.a = gstate->size * gstate->scale;
 	tsm.b = 0;
 	tsm.c = 0;
 	tsm.d = gstate->size;
 	tsm.e = 0;
 	tsm.f = gstate->rise;
 
 	if (fontdesc->tounicode)
-		ucs = pdf_lookupcmap(fontdesc->tounicode, cid);
-	else if (cid < fontdesc->ncidtoucs)
-		ucs = fontdesc->cidtoucs[cid];
-	else
-		ucs = '?';
+		ucs[1] = pdf_lookupcmap(fontdesc->tounicode, cid);
+	if (ucs[1] < -1)
+	{
+		/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=788 */
+		/* prepare to add multiple characters (e.g. a ligature) */
+		int j, offset = -ucs[1] - 2;
+		ucs[0] = fontdesc->tounicode->table[offset];
+		for (j = 1; j <= ucs[0]; j++)
+			ucs[j] = fontdesc->tounicode->table[offset + j];
+	}
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=787 */
+	/* fall back to ncidtoucs if the char wasn't in tounicode */
+	if (ucs[1] < 0 && cid < fontdesc->ncidtoucs)
+		ucs[1] = fontdesc->cidtoucs[cid];
+	if (ucs[1] < 0)
+		ucs[1] = '?';
 
 	gid = pdf_fontcidtogid(fontdesc, cid);
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=855 */
+	/* some chinese fonts only ship the similarly looking 0x2026 */
+	if (gid == 0 && ucs[1] == 0x22ef && fontdesc->font->ftface)
+	{
+		gid = FT_Get_Char_Index(fontdesc->font->ftface, 0x2026);
+	}
 
 	if (fontdesc->wmode == 1)
 	{
 		v = pdf_getvmtx(fontdesc, cid);
 		tsm.e -= v.x * gstate->size / 1000.0;
 		tsm.f -= v.y * gstate->size / 1000.0;
 	}
 
diff -r 27dbba5ea9e6 mupdf/pdf_cmap.c
--- a/mupdf/pdf_cmap.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_cmap.c	Sat May 01 23:42:01 2010 +0200
@@ -371,17 +371,19 @@ pdf_lookupcmap(pdf_cmap *cmap, int cpt)
 		else if (cpt > cmap->ranges[m].high)
 			l = m + 1;
 		else
 		{
 			int i = cpt - cmap->ranges[m].low + cmap->ranges[m].offset;
 			if (cmap->ranges[m].flag == PDF_CMAP_TABLE)
 				return cmap->table[i];
 			if (cmap->ranges[m].flag == PDF_CMAP_MULTI)
-				return -1;
+				/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=788 */
+				/* allow callers to detect that this was a multi-character mapping */
+				return -2 - cmap->ranges[m].offset;
 			return i;
 		}
 	}
 
 	if (cmap->usecmap)
 		return pdf_lookupcmap(cmap->usecmap, cpt);
 
 	return -1;
diff -r 27dbba5ea9e6 mupdf/pdf_cmap_parse.c
--- a/mupdf/pdf_cmap_parse.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_cmap_parse.c	Sat May 01 23:42:01 2010 +0200
@@ -387,18 +387,19 @@ pdf_parsecmap(pdf_cmap **cmapp, fz_strea
 
 	strcpy(key, ".notdef");
 
 	while (1)
 	{
 		error = pdf_lexcmap(&tok, file, buf, sizeof buf, &len);
 		if (error)
 		{
-			error = fz_rethrow(error, "syntaxerror in cmap");
-			goto cleanup;
+			/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=642 */
+			fz_warn("syntaxerror in cmap");
+			tok = PDF_TEOF;
 		}
 
 		if (tok == PDF_TEOF || tok == TENDCMAP)
 			break;
 
 		else if (tok == PDF_TNAME)
 		{
 			if (!strcmp(buf, "CMapName"))
diff -r 27dbba5ea9e6 mupdf/pdf_colorspace.c
--- a/mupdf/pdf_colorspace.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_colorspace.c	Sat May 01 23:42:01 2010 +0200
@@ -147,16 +147,77 @@ void pdf_convpixmap(fz_colorspace *ss, f
 		if (ds == pdf_devicegray) fastcmyktogray(sp, dp);
 		else if (ds == pdf_devicergb) fastcmyktorgb(sp, dp);
 		else fz_stdconvpixmap(ss, sp, ds, dp);
 	}
 
 	else fz_stdconvpixmap(ss, sp, ds, dp);
 }
 
+/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=756 */
+/* function adapted from Poppler's GfxState_helpers.h
+   Poppler is licensed under GPL, see http://poppler.freedesktop.org/ */
+static inline void cmykToRGBMatrixMultiplication(float *sv, float *dv)
+{
+	float c = sv[0], m = sv[1], y = sv[2], k = sv[3];
+	float c1 = 1 - c, m1 = 1 - m, y1 = 1 - y, k1 = 1 - k;
+	float r, g, b, x;
+
+	// this is a matrix multiplication, unrolled for performance
+	//                        C M Y K
+	x = c1 * m1 * y1 * k1; // 0 0 0 0
+	r = g = b = x;
+	x = c1 * m1 * y1 * k;  // 0 0 0 1
+	r += 0.1373 * x;
+	g += 0.1216 * x;
+	b += 0.1255 * x;
+	x = c1 * m1 * y  * k1; // 0 0 1 0
+	r += x;
+	g += 0.9490 * x;
+	x = c1 * m1 * y  * k;  // 0 0 1 1
+	r += 0.1098 * x;
+	g += 0.1020 * x;
+	x = c1 * m  * y1 * k1; // 0 1 0 0
+	r += 0.9255 * x;
+	b += 0.5490 * x;
+	x = c1 * m  * y1 * k;  // 0 1 0 1
+	r += 0.1412 * x;
+	x = c1 * m  * y  * k1; // 0 1 1 0
+	r += 0.9294 * x;
+	g += 0.1098 * x;
+	b += 0.1412 * x;
+	x = c1 * m  * y  * k;  // 0 1 1 1
+	r += 0.1333 * x;
+	x = c  * m1 * y1 * k1; // 1 0 0 0
+	g += 0.6784 * x;
+	b += 0.9373 * x;
+	x = c  * m1 * y1 * k;  // 1 0 0 1
+	g += 0.0588 * x;
+	b += 0.1412 * x;
+	x = c  * m1 * y  * k1; // 1 0 1 0
+	g += 0.6510 * x;
+	b += 0.3137 * x;
+	x = c  * m1 * y  * k;  // 1 0 1 1
+	g += 0.0745 * x;
+	x = c  * m  * y1 * k1; // 1 1 0 0
+	r += 0.1804 * x;
+	g += 0.1922 * x;
+	b += 0.5725 * x;
+	x = c  * m  * y1 * k;  // 1 1 0 1
+	b += 0.0078 * x;
+	x = c  * m  * y  * k1; // 1 1 1 0
+	r += 0.2118 * x;
+	g += 0.2119 * x;
+	b += 0.2235 * x;
+
+	dv[0] = MIN(MAX(r, 0), 1);
+	dv[1] = MIN(MAX(g, 0), 1);
+	dv[2] = MIN(MAX(b, 0), 1);
+}
+
 void pdf_convcolor(fz_colorspace *ss, float *sv, fz_colorspace *ds, float *dv)
 {
 
 	if (ss == pdf_devicegray)
 	{
 		if (ds == pdf_devicergb)
 		{
 			dv[0] = sv[0];
@@ -201,19 +262,22 @@ void pdf_convcolor(fz_colorspace *ss, fl
 		{
 			float c = sv[1] * 0.3;
 			float m = sv[2] * 0.59;
 			float y = sv[2] * 0.11;
 			dv[0] = 1.0 - MIN(c + m + y + sv[3], 1.0);
 		}
 		else if (ds == pdf_devicergb)
 		{
+			/*
 			dv[0] = 1.0 - MIN(sv[0] + sv[3], 1.0);
 			dv[1] = 1.0 - MIN(sv[1] + sv[3], 1.0);
 			dv[2] = 1.0 - MIN(sv[2] + sv[3], 1.0);
+			*/
+			cmykToRGBMatrixMultiplication(sv, dv); /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=756 */
 		}
 		else
 			fz_stdconvcolor(ss, sv, ds, dv);
 	}
 
 	else
 		fz_stdconvcolor(ss, sv, ds, dv);
 }
diff -r 27dbba5ea9e6 mupdf/pdf_font.c
--- a/mupdf/pdf_font.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_font.c	Sat May 01 23:42:01 2010 +0200
@@ -1,14 +1,27 @@
 #include "fitz.h"
 #include "mupdf.h"
 
+#ifndef WIN32
+/* TODO: should build freetype from sources in unix/mac build as well */
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_XFREE86_H
+#else
+/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=687 */
+/* for accessing to the internal Type 1 specific structures (for extracting the embedded encoding table) */
+#define FT2_BUILD_LIBRARY
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_XFREE86_H
+
+#include FT_INTERNAL_INTERNAL_H
+#include FT_INTERNAL_TYPE1_TYPES_H
+#endif
 
 static char *basefontnames[14][7] =
 {
 	{ "Courier", "CourierNew", "CourierNewPSMT", nil },
 	{ "Courier-Bold", "CourierNew,Bold", "Courier,Bold",
 		"CourierNewPS-BoldMT", "CourierNew-Bold", nil },
 	{ "Courier-Oblique", "CourierNew,Italic", "Courier,Italic",
 		"CourierNewPS-ItalicMT", "CourierNew-Italic", nil },
@@ -88,16 +101,59 @@ static int ftkind(FT_Face face)
 static int ftcharindex(FT_Face face, int cid)
 {
 	int gid = FT_Get_Char_Index(face, cid);
 	if (gid == 0)
 		gid = FT_Get_Char_Index(face, 0xf000 + cid);
 	return gid;
 }
 
+/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=687 */
+/* extract the Type 1 font's embedded encoding table */
+#ifdef WIN32
+static int ftloadt1encoding(FT_Face face, char **estrings)
+{
+	T1_Encoding encoding;
+	T1_Font font;
+	int i;
+
+	/* not (yet) implemented for CFF and CID fonts */
+	if (strcmp(FT_Get_X11_Font_Format(face), "Type 1") != 0)
+		return 0;
+
+	font = &((T1_Face)face)->type1;
+	switch (font->encoding_type)
+	{
+	case T1_ENCODING_TYPE_STANDARD:
+		pdf_loadencoding(estrings, "StandardEncoding");
+		return 1;
+	case T1_ENCODING_TYPE_ISOLATIN1:
+		pdf_loadencoding(estrings, "WinAnsiEncoding");
+		return 1;
+	case T1_ENCODING_TYPE_EXPERT:
+		pdf_loadencoding(estrings, "MacExpertEncoding");
+		return 1;
+	case T1_ENCODING_TYPE_ARRAY:
+		encoding = &font->encoding;
+		if (encoding->code_first == encoding->code_last)
+			break;
+		assert(encoding->code_first < encoding->code_last && encoding->code_last <= 256);
+		for (i = encoding->code_first; i < encoding->code_last; i++)
+			estrings[i] = encoding->char_name[i];
+		return 1;
+	}
+	return 0;
+}
+#else
+static int ftloadt1encoding(FT_Face face, char **estrings)
+{
+  return 0;
+}
+#endif
+
 static inline int ftcidtogid(pdf_fontdesc *fontdesc, int cid)
 {
 	if (fontdesc->tottfcmap)
 	{
 		cid = pdf_lookupcmap(fontdesc->tottfcmap, cid);
 		return ftcharindex(fontdesc->font->ftface, cid);
 	}
 
@@ -264,17 +320,17 @@ loadsimplefont(pdf_fontdesc **fontdescp,
 
 	fontdesc = pdf_newfontdesc();
 
 	pdf_logfont("load simple font (%d %d R) ptr=%p {\n", fz_tonum(dict), fz_togen(dict), fontdesc);
 	pdf_logfont("basefont0 %s\n", basefont);
 	pdf_logfont("basefont1 %s\n", fontname);
 
 	descriptor = fz_dictgets(dict, "FontDescriptor");
-	if (descriptor && basefont == fontname)
+	if (descriptor) /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=664 */
 		error = pdf_loadfontdescriptor(fontdesc, xref, descriptor, nil);
 	else
 		error = pdf_loadbuiltinfont(fontdesc, fontname);
 	if (error)
 		goto cleanup;
 
 	face = fontdesc->font->ftface;
 	kind = ftkind(face);
@@ -305,17 +361,20 @@ loadsimplefont(pdf_fontdesc **fontdescp,
 		cmap = nil;
 
 	for (i = 0; i < face->num_charmaps; i++)
 	{
 		FT_CharMap test = face->charmaps[i];
 
 		if (kind == TYPE1)
 		{
-			if (test->platform_id == 7)
+			/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=664 */
+			if (test->platform_id == 3 && test->encoding_id == 1)
+				cmap = test;
+			if (test->platform_id == 7 && test->encoding_id == 2)
 				cmap = test;
 		}
 
 		if (kind == TRUETYPE)
 		{
 			if (test->platform_id == 1 && test->encoding_id == 0)
 				cmap = test;
 			if (test->platform_id == 3 && test->encoding_id == 1)
@@ -335,30 +394,38 @@ loadsimplefont(pdf_fontdesc **fontdescp,
 	etable = fz_malloc(sizeof(unsigned short) * 256);
 	for (i = 0; i < 256; i++)
 	{
 		estrings[i] = nil;
 		etable[i] = 0;
 	}
 
 	encoding = fz_dictgets(dict, "Encoding");
+	/* ignore invalid Encoding names; cf. http://code.google.com/p/sumatrapdf/issues/detail?id=771 */
+	if (fz_isname(encoding) && !strstr(fz_toname(encoding), "Encoding"))
+		encoding = nil;
 	if (encoding && !(kind == TRUETYPE && symbolic))
 	{
 		if (fz_isname(encoding))
 			pdf_loadencoding(estrings, fz_toname(encoding));
 
 		if (fz_isdict(encoding))
 		{
 			fz_obj *base, *diff, *item;
 
 			base = fz_dictgets(encoding, "BaseEncoding");
 			if (fz_isname(base))
 				pdf_loadencoding(estrings, fz_toname(base));
 			else if (!fontdesc->isembedded)
 				pdf_loadencoding(estrings, "StandardEncoding");
+			/* cf. http://bugs.ghostscript.com/show_bug.cgi?id=690615 and http://code.google.com/p/sumatrapdf/issues/detail?id=687 */
+			/* try to extract an encoding from the font or synthesize a likely one */
+			/* note: FT_Get_Name_Index fails for symbolic CFF fonts, so let them be encoded by index */
+			else if (!fontdesc->encoding && !ftloadt1encoding(face, estrings) && !(symbolic && !strcmp(FT_Get_X11_Font_Format(face), "CFF")))
+				pdf_loadencoding(estrings, "StandardEncoding");
 
 			diff = fz_dictgets(encoding, "Differences");
 			if (fz_isarray(diff))
 			{
 				n = fz_arraylen(diff);
 				k = 0;
 				for (i = 0; i < n; i++)
 				{
@@ -482,16 +549,46 @@ loadsimplefont(pdf_fontdesc **fontdescp,
 				{
 					error = fz_throw("freetype get glyph name (gid %d): %s", etable[i], ft_errorstring(fterr));
 					goto cleanup;
 				}
 				if (ebuffer[i][0])
 					estrings[i] = ebuffer[i];
 			}
 		}
+
+		/* Load a default encoding for TrueType fonts with a charmap */
+		/* (this is likely not quite correct, though...) */
+		/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=779 */
+		if (!FT_HAS_GLYPH_NAMES(face) && face->charmap && kind == TRUETYPE)
+			pdf_loadencoding(estrings, "WinAnsiEncoding");
+
+		/* Load encoding Differences nonetheless, when they're available */
+		/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=115 */
+		if (fz_isdict(encoding))
+		{
+			fz_obj *diff, *item;
+
+			diff = fz_dictgets(encoding, "Differences");
+			if (fz_isarray(diff))
+			{
+				n = fz_arraylen(diff);
+				k = 0;
+				for (i = 0; i < n; i++)
+				{
+					item = fz_arrayget(diff, i);
+					if (fz_isint(item))
+						k = fz_toint(item);
+					if (fz_isname(item))
+						estrings[k++] = fz_toname(item);
+					if (k < 0) k = 0;
+					if (k > 255) k = 255;
+				}
+			}
+		}
 	}
 
 	fontdesc->encoding = pdf_newidentitycmap(0, 1);
 	fontdesc->ncidtogid = 256;
 	fontdesc->cidtogid = etable;
 
 	error = pdf_loadtounicode(fontdesc, xref, estrings, nil, fz_dictgets(dict, "ToUnicode"));
 	if (error)
@@ -534,20 +631,20 @@ loadsimplefont(pdf_fontdesc **fontdescp,
 	pdf_endhmtx(fontdesc);
 
 	pdf_logfont("}\n");
 
 	*fontdescp = fontdesc;
 	return fz_okay;
 
 cleanup:
-	if (etable)
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=487 */
+	if (etable != fontdesc->cidtogid)
 		fz_free(etable);
-	fz_dropfont(fontdesc->font);
-	fz_free(fontdesc);
+	pdf_dropfont(fontdesc);
 	return fz_rethrow(error, "cannot load simple font");
 }
 
 /*
  * CID Fonts
  */
 
 static fz_error
diff -r 27dbba5ea9e6 mupdf/pdf_fontfile.c
--- a/mupdf/pdf_fontfile.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_fontfile.c	Sat May 01 23:42:01 2010 +0200
@@ -27,17 +27,17 @@ extern const unsigned char pdf_font_Nimb
 extern const unsigned int  pdf_font_NimbusSanL_Regu_cff_len;
 extern const unsigned char pdf_font_NimbusSanL_ReguItal_cff_buf[];
 extern const unsigned int  pdf_font_NimbusSanL_ReguItal_cff_len;
 extern const unsigned char pdf_font_StandardSymL_cff_buf[];
 extern const unsigned int  pdf_font_StandardSymL_cff_len;
 extern const unsigned char pdf_font_URWChanceryL_MediItal_cff_buf[];
 extern const unsigned int  pdf_font_URWChanceryL_MediItal_cff_len;
 
-#ifndef NOCJK
+#if !defined(NOCJK) && !defined(NOCJKFONT)
 extern const unsigned char pdf_font_DroidSansFallback_ttf_buf[];
 extern const unsigned int  pdf_font_DroidSansFallback_ttf_len;
 #endif
 
 enum
 {
 	FD_FIXED = 1 << 0,
 	FD_SERIF = 1 << 1,
@@ -102,50 +102,711 @@ static const struct
 		pdf_font_Dingbats_cff_buf,
 		&pdf_font_Dingbats_cff_len },
 	{ "Chancery",
 		pdf_font_URWChanceryL_MediItal_cff_buf,
 		&pdf_font_URWChanceryL_MediItal_cff_len },
 	{ nil, nil, nil }
 };
 
+#ifdef WIN32
+/***** start of Windows font loading code *****/
+
+#include <windows.h>
+#include <tchar.h>
+
+// TODO: Use more of FreeType for TTF parsing (for performance reasons,
+//       the fonts can't be parsed completely, though)
+#include <ft2build.h>
+#include FT_TRUETYPE_IDS_H
+#include FT_TRUETYPE_TAGS_H
+
+#define SWAPWORD(x)		MAKEWORD(HIBYTE(x), LOBYTE(x))
+#define SWAPLONG(x)		MAKELONG(SWAPWORD(HIWORD(x)), SWAPWORD(LOWORD(x)))
+
+#define TTC_VERSION1	0x00010000
+#define TTC_VERSION2	0x00020000
+
+#define MAX_FACENAME	128
+
+// Note: the font face must be the first field so that the structure
+//       can be considered a simple string for searching
+typedef struct pdf_fontmapMS_s
+{
+	char fontface[MAX_FACENAME]; // UTF-8 encoded
+	char fontpath[MAX_PATH * 2]; // UTF-8 encoded (when compiled with _UNICODE)
+	int index;
+} pdf_fontmapMS;
+
+typedef struct pdf_fontlistMS_s
+{
+	pdf_fontmapMS *fontmap;
+	int len;
+	int cap;
+} pdf_fontlistMS;
+
+typedef struct _tagTT_OFFSET_TABLE
+{
+	ULONG	uVersion;
+	USHORT	uNumOfTables;
+	USHORT	uSearchRange;
+	USHORT	uEntrySelector;
+	USHORT	uRangeShift;
+} TT_OFFSET_TABLE;
+
+typedef struct _tagTT_TABLE_DIRECTORY
+{
+	ULONG	uTag;				//table name
+	ULONG	uCheckSum;			//Check sum
+	ULONG	uOffset;			//Offset from beginning of file
+	ULONG	uLength;			//length of the table in bytes
+} TT_TABLE_DIRECTORY;
+
+typedef struct _tagTT_NAME_TABLE_HEADER
+{
+	USHORT	uFSelector;			//format selector. Always 0
+	USHORT	uNRCount;			//Name Records count
+	USHORT	uStorageOffset;		//Offset for strings storage, from start of the table
+} TT_NAME_TABLE_HEADER;
+
+typedef struct _tagTT_NAME_RECORD
+{
+	USHORT	uPlatformID;
+	USHORT	uEncodingID;
+	USHORT	uLanguageID;
+	USHORT	uNameID;
+	USHORT	uStringLength;
+	USHORT	uStringOffset;	//from start of storage area
+} TT_NAME_RECORD;
+
+typedef struct _tagFONT_COLLECTION
+{
+	ULONG	Tag;
+	ULONG	Version;
+	ULONG	NumFonts;
+} FONT_COLLECTION;
+
+static struct {
+	char *name;
+	char *pattern;
+} baseSubstitutes[] = {
+	{ "Courier", "CourierNewPSMT" },
+	{ "Courier-Bold", "CourierNewPS-BoldMT" },
+	{ "Courier-Oblique", "CourierNewPS-ItalicMT" },
+	{ "Courier-BoldOblique", "CourierNewPS-BoldItalicMT" },
+	{ "Helvetica", "ArialMT" },
+	{ "Helvetica-Bold", "Arial-BoldMT" },
+	{ "Helvetica-Oblique", "Arial-ItalicMT" },
+	{ "Helvetica-BoldOblique", "Arial-BoldItalicMT" },
+	{ "Times-Roman", "TimesNewRomanPSMT" },
+	{ "Times-Bold", "TimesNewRomanPS-BoldMT" },
+	{ "Times-Italic", "TimesNewRomanPS-ItalicMT" },
+	{ "Times-BoldItalic", "TimesNewRomanPS-BoldItalicMT" },
+	{ "Symbol", "SymbolMT" },
+};
+
+static pdf_fontlistMS fontlistMS =
+{
+	NULL,
+	0,
+	0,
+};
+
+/* A little bit more sophisticated name matching so that e.g. "EurostileExtended"
+   matches "EurostileExtended-Roman" or "Tahoma-Bold,Bold" matches "Tahoma-Bold" */
+static int
+lookupcompare(const void *elem1, const void *elem2)
+{
+	char *val1 = (char *)elem1;
+	char *val2 = (char *)elem2;
+	int len1 = strlen(val1);
+	int len2 = strlen(val2);
+
+	if (len1 != len2)
+	{
+		char *rest = len1 > len2 ? val1 + len2 : val2 + len1;
+		if (',' == *rest || !stricmp(rest, "-roman"))
+			return strnicmp(val1, val2, MIN(len1, len2));
+	}
+
+	return stricmp(val1, val2);
+}
+
+static void
+removespaces(char *srcDest)
+{
+	char *dest;
+
+	for (dest = srcDest; *srcDest; srcDest++)
+		if (*srcDest != ' ')
+			*dest++ = *srcDest;
+	*dest = 0;
+}
+
+/* source and dest can be same */
+static fz_error
+decodeunicodeBMP(char* source, int sourcelen, char* dest, int destlen)
+{
+	wchar_t tmp[1024 * 2];
+	int converted, i;
+
+	if (sourcelen % 2 != 0)
+		return fz_throw("fonterror");
+
+	memset(tmp, 0, sizeof(tmp));
+	for (i = 0; i < sourcelen / 2; i++)
+		tmp[i] = SWAPWORD(((wchar_t *)source)[i]);
+
+	converted = WideCharToMultiByte(CP_UTF8, 0, tmp, -1, dest, destlen, NULL, NULL);
+	if (converted == 0)
+		return fz_throw("fonterror");
+
+	return fz_okay;
+}
+
+static fz_error
+decodeplatformstring(int platform, int enctype, char* source, int sourcelen, char* dest, int destlen)
+{
+	switch (platform)
+	{
+	case TT_PLATFORM_APPLE_UNICODE:
+		switch (enctype)
+		{
+		case TT_APPLE_ID_DEFAULT:
+		case TT_APPLE_ID_UNICODE_2_0:
+			return decodeunicodeBMP(source, sourcelen, dest, destlen);
+		}
+		return fz_throw("fonterror : unsupported encoding");
+	case TT_PLATFORM_MACINTOSH:
+		switch( enctype)
+		{
+		case TT_MAC_ID_ROMAN:
+			if (sourcelen + 1 > destlen)
+				return fz_throw("fonterror : short buf lenth");
+			// TODO: Convert to UTF-8 from what encoding?
+			memcpy(source, dest, sourcelen);
+			dest[sourcelen] = 0;
+			return fz_okay;
+		}
+		return fz_throw("fonterror : unsupported encoding");
+	case TT_PLATFORM_MICROSOFT:
+		switch (enctype)
+		{
+		case TT_MS_ID_SYMBOL_CS:
+		case TT_MS_ID_UNICODE_CS:
+		case TT_MS_ID_UCS_4:
+			return decodeunicodeBMP(source, sourcelen, dest, destlen);
+		}
+		return fz_throw("fonterror : unsupported encoding");
+	default:
+		return fz_throw("fonterror : unsupported platform");
+	}
+}
+
+static fz_error
+growfontlist(pdf_fontlistMS *fl)
+{
+	int newcap;
+	pdf_fontmapMS *newitems;
+
+	if (fl->cap == 0)
+		newcap = 1024;
+	else
+		newcap = fl->cap * 2;
+
+	newitems = fz_realloc(fl->fontmap, sizeof(pdf_fontmapMS) * newcap);
+	if (!newitems)
+		return fz_rethrow(-1, "out of memory");;
+
+	memset(newitems + fl->cap, 0, sizeof(pdf_fontmapMS) * (newcap - fl->cap));
+
+	fl->fontmap = newitems;
+	fl->cap = newcap;
+
+	return fz_okay;
+}
+
+static fz_error
+insertmapping(pdf_fontlistMS *fl, char *facename, char *path, int index)
+{
+	if (fl->len == fl->cap)
+	{
+		fz_error err = growfontlist(fl);
+		if (err) return err;
+	}
+
+	if (fl->len >= fl->cap)
+		return fz_throw("fonterror : fontlist overflow");
+
+	fz_strlcpy(fl->fontmap[fl->len].fontface, facename, sizeof(fl->fontmap[0].fontface));
+	fz_strlcpy(fl->fontmap[fl->len].fontpath, path, sizeof(fl->fontmap[0].fontpath));
+	fl->fontmap[fl->len].index = index;
+
+	++fl->len;
+
+	return fz_okay;
+}
+
+static fz_error
+safe_read(fz_stream *file, char *buf, int size)
+{
+	int bytesRead;
+	fz_error err = fz_read(&bytesRead, file, buf, size);
+	if (err)
+		return err;
+
+	if (bytesRead != size)
+		return fz_throw("ioerror");
+	return fz_okay;
+}
+
+static fz_error
+read_ttf_string(fz_stream *file, int offset, TT_NAME_RECORD *ttRecord, char *buf, int size)
+{
+	fz_error err;
+	char szTemp[MAX_FACENAME * 2];
+	// ignore empty and overlong strings
+	int stringLength = SWAPWORD(ttRecord->uStringLength);
+	if (stringLength == 0 || stringLength >= sizeof(szTemp))
+		return fz_okay;
+
+	fz_seek(file, offset + SWAPWORD(ttRecord->uStringOffset), 0);
+	err = safe_read(file, szTemp, stringLength);
+	if (err) return err;
+	return decodeplatformstring(SWAPWORD(ttRecord->uPlatformID), SWAPWORD(ttRecord->uEncodingID),
+		szTemp, stringLength, buf, size);
+}
+
+static fz_error
+parseTTF(fz_stream *file, int offset, int index, char *path)
+{
+	fz_error err = fz_okay;
+
+	TT_OFFSET_TABLE ttOffsetTable;
+	TT_TABLE_DIRECTORY tblDir;
+	TT_NAME_TABLE_HEADER ttNTHeader;
+	TT_NAME_RECORD ttRecord;
+
+	char szPSName[MAX_FACENAME] = { 0 }, szTTName[MAX_FACENAME] = { 0 }, szStyle[MAX_FACENAME] = { 0 };
+	int i, count, tblOffset;
+
+	fz_seek(file,offset,0);
+	err = safe_read(file, (char *)&ttOffsetTable, sizeof(TT_OFFSET_TABLE));
+	if (err) return err;
+
+	// check if this is a TrueType font of version 1.0 or an OpenType font
+	if (SWAPLONG(ttOffsetTable.uVersion) != TTC_VERSION1 && ttOffsetTable.uVersion != TTAG_OTTO)
+	{
+		return fz_throw("fonterror : invalid font version");
+	}
+
+	// determine the name table's offset by iterating through the offset table
+	count = SWAPWORD(ttOffsetTable.uNumOfTables);
+	for (i = 0; i < count; i++)
+	{
+		err = safe_read(file, (char *)&tblDir, sizeof(TT_TABLE_DIRECTORY));
+		if (err) return err;
+		if (!tblDir.uTag || SWAPLONG(tblDir.uTag) == TTAG_name)
+			break;
+	}
+	if (count == i || !tblDir.uTag)
+		return fz_throw("fonterror : nameless font");
+	tblOffset = SWAPLONG(tblDir.uOffset);
+
+	// read the 'name' table for record count and offsets
+	fz_seek(file, tblOffset, 0);
+	err = safe_read(file, (char *)&ttNTHeader, sizeof(TT_NAME_TABLE_HEADER));
+	if (err) return err;
+	offset = tblOffset + sizeof(TT_NAME_TABLE_HEADER);
+	tblOffset += SWAPWORD(ttNTHeader.uStorageOffset);
+
+	// read through the strings for PostScript name and font family
+	count = SWAPWORD(ttNTHeader.uNRCount);
+	for (i = 0; i < count; i++)
+	{
+		short nameId;
+
+		fz_seek(file, offset + i * sizeof(TT_NAME_RECORD), 0);
+		err = safe_read(file, (char *)&ttRecord, sizeof(TT_NAME_RECORD));
+		if (err) return err;
+
+		// ignore non-English strings
+		if (ttRecord.uLanguageID && SWAPWORD(ttRecord.uLanguageID) != TT_MS_LANGID_ENGLISH_UNITED_STATES)
+			continue;
+		// ignore names other than font (sub)family and PostScript name
+		nameId = SWAPWORD(ttRecord.uNameID);
+		if (TT_NAME_ID_FONT_FAMILY == nameId)
+			err = read_ttf_string(file, tblOffset, &ttRecord, szTTName, MAX_FACENAME);
+		else if (TT_NAME_ID_FONT_SUBFAMILY == nameId)
+			err = read_ttf_string(file, tblOffset, &ttRecord, szStyle, MAX_FACENAME);
+		else if (TT_NAME_ID_PS_NAME == nameId)
+			err = read_ttf_string(file, tblOffset, &ttRecord, szPSName, MAX_FACENAME);
+		if (err) return err;
+	}
+
+	if (szPSName[0])
+	{
+		err = insertmapping(&fontlistMS, szPSName, path, index);
+		if (err) return err;
+	}
+	if (szTTName[0])
+	{
+		// derive a PostScript-like name and add it, if it's different from the font's
+		// included PostScript name; cf. http://code.google.com/p/sumatrapdf/issues/detail?id=376
+
+		// append the font's subfamily, unless it's a Regular font
+		if (szStyle[0] && stricmp(szStyle, "Regular") != 0)
+		{
+			fz_strlcat(szTTName, "-", MAX_FACENAME);
+			fz_strlcat(szTTName, szStyle, MAX_FACENAME);
+		}
+		removespaces(szTTName);
+		// compare the two names before adding this one
+		if (lookupcompare(szTTName, szPSName))
+		{
+			err = insertmapping(&fontlistMS, szTTName, path, index);
+			if (err) return err;
+		}
+	}
+	return fz_okay;
+}
+
+static fz_error
+parseTTFs(char *path)
+{
+	fz_stream *file = nil;
+	fz_error err = fz_openrfile(&file, path);
+	if (!err)
+		err = parseTTF(file, 0, 0, path);
+
+	if (file)
+		fz_dropstream(file);
+	return err;
+}
+
+static fz_error
+parseTTCs(char *path)
+{
+	fz_stream *file = nil;
+	FONT_COLLECTION fontcollection;
+	ULONG i, numFonts, *offsettable = nil;
+
+	fz_error err = fz_openrfile(&file, path);
+	if (err) goto cleanup;
+
+	err = safe_read(file, (char *)&fontcollection, sizeof(FONT_COLLECTION));
+	if (err) goto cleanup;
+	if (SWAPLONG(fontcollection.Tag) != TTAG_ttcf)
+	{
+		err = fz_throw("fonterror : wrong format");
+		goto cleanup;
+	}
+
+	if (SWAPLONG(fontcollection.Version) != TTC_VERSION1 && SWAPLONG(fontcollection.Version) != TTC_VERSION2)
+	{
+		err = fz_throw("fonterror : invalid version");
+		goto cleanup;
+	}
+
+	numFonts = SWAPLONG(fontcollection.NumFonts);
+	offsettable = fz_malloc(numFonts * sizeof(ULONG));
+	if (offsettable == nil)
+	{
+		err = fz_throw("out of memory");
+		goto cleanup;
+	}
+
+	err = safe_read(file, (char *)offsettable, numFonts * sizeof(ULONG));
+	for (i = 0; i < numFonts && !err; i++)
+	{
+		err = parseTTF(file, SWAPLONG(offsettable[i]), i, path);
+	}
+
+cleanup:
+	if (offsettable)
+		fz_free(offsettable);
+	if (file)
+		fz_dropstream(file);
+
+	return err;
+}
+
+static fz_error
+pdf_createfontlistMS()
+{
+	TCHAR szFontDir[MAX_PATH], szFile[MAX_PATH];
+	char szPathUtf8[MAX_PATH * 3], *fileExt;
+	HANDLE hList;
+	WIN32_FIND_DATA FileData;
+
+	// Get the proper directory path
+	GetWindowsDirectory(szFontDir, _countof(szFontDir));
+	_tcscat_s(szFontDir, MAX_PATH, _T("\\Fonts\\*.?t?"));
+
+	hList = FindFirstFile(szFontDir, &FileData);
+	if (hList == INVALID_HANDLE_VALUE)
+	{
+		/* Don't complain about missing directories */
+		if (errno == ENOENT)
+			return fz_throw("fonterror : can't find system fonts dir");
+		return fz_throw("ioerror");
+	}
+	// drop the wildcards
+	szFontDir[lstrlen(szFontDir) - 5] = 0;
+	// Traverse through the directory structure
+	do
+	{
+		if (!(FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+		{
+			// Get the full path for sub directory
+			_stprintf_s(szFile, MAX_PATH, _T("%s%s"), szFontDir, FileData.cFileName);
+#ifdef _UNICODE
+			WideCharToMultiByte(CP_UTF8, 0, szFile, -1, szPathUtf8, sizeof(szPathUtf8), NULL, NULL);
+#else
+			// fz_openrfile falls back to the ANSI code page if the string isn't proper UTF-8
+			strcpy(szPathUtf8, szFile);
+#endif
+			fileExt = szPathUtf8 + strlen(szPathUtf8) - 4;
+			if (!stricmp(fileExt, ".ttc"))
+				parseTTCs(szPathUtf8);
+			else if (!stricmp(fileExt, ".ttf") || !stricmp(fileExt, ".otf"))
+				parseTTFs(szPathUtf8);
+			// ignore errors occurring while parsing a given font file
+		}
+	} while (FindNextFile(hList, &FileData));
+	FindClose(hList);
+
+#ifdef NOCJKFONT
+	{
+		// If no CJK fallback font is builtin but one has been shipped separately (in the same
+		// directory as the main executable), add it to the list of loadable system fonts
+		TCHAR *lpFileName;
+		HANDLE hFile;
+
+		GetModuleFileName(0, szFontDir, MAX_PATH);
+		GetFullPathName(szFontDir, MAX_PATH, szFile, &lpFileName);
+		lstrcpyn(lpFileName, _T("DroidSansFallback.ttf"), MAX_PATH - (lpFileName - szFile));
+
+		hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
+		if (hFile != INVALID_HANDLE_VALUE)
+		{
+#ifdef _UNICODE
+			WideCharToMultiByte(CP_UTF8, 0, szFile, -1, szPathUtf8, sizeof(szPathUtf8), NULL, NULL);
+#else
+			strcpy(szPathUtf8, szFile);
+#endif
+			insertmapping(&fontlistMS, "DroidSansFallback", szPathUtf8, 0);
+			CloseHandle(hFile);
+		}
+	}
+#endif
+
+	// sort the font list, so that it can be searched binarily
+	qsort(fontlistMS.fontmap, fontlistMS.len, sizeof(pdf_fontmapMS), stricmp);
+	// TODO: make "TimesNewRomanPSMT" default substitute font?
+
+	return fz_okay;
+}
+
+void
+pdf_destroyfontlistMS()
+{
+	if (fontlistMS.fontmap != nil)
+		fz_free(fontlistMS.fontmap);
+
+	fontlistMS.len = 0;
+	fontlistMS.cap = 0;
+}
+
+static fz_error
+loadwindowsfont(pdf_fontdesc *font, char *fontname)
+{
+	fz_error error;
+	pdf_fontmapMS *found = nil;
+	char *comma;
+
+	if (fontlistMS.len == 0)
+	{
+		pdf_createfontlistMS();
+		if (fontlistMS.len == 0)
+			return fz_throw("fonterror : no fonts in the system");
+	}
+
+	pdf_logfont("win32: try load font `%s'\n", fontname);
+
+	// work on a normalized copy of the font name
+	fontname = strdup(fontname);
+	removespaces(fontname);
+
+	// first, try to find the exact font name (including appended style information)
+	comma = strchr(fontname, ',');
+	if (comma)
+	{
+		*comma = '-';
+		found = bsearch(fontname, fontlistMS.fontmap, fontlistMS.len, sizeof(pdf_fontmapMS), lookupcompare);
+		*comma = ',';
+	}
+	// second, substitute the font name with a known PostScript name
+	if (!found)
+	{
+		int i;
+		for (i = 0; i < _countof(baseSubstitutes); i++)
+			if (!strcmp(fontname, baseSubstitutes[i].name))
+				break;
+		if (i < _countof(baseSubstitutes))
+			found = bsearch(baseSubstitutes[i].pattern, fontlistMS.fontmap, fontlistMS.len, sizeof(pdf_fontmapMS), lookupcompare);
+	}
+	// third, search for the font name without additional style information
+	if (!found)
+		found = bsearch(fontname, fontlistMS.fontmap, fontlistMS.len, sizeof(pdf_fontmapMS), lookupcompare);
+	free(fontname);
+
+	if (!found)
+		return !fz_okay;
+
+	error = fz_newfontfromfile(&font->font, found->fontpath, found->index);
+	if (error)
+		return fz_rethrow(error, "cannot load freetype font from a file %s", found->fontpath);
+
+	pdf_logfont("win32: load font from `%s'\n", found->fontpath);
+
+	return fz_okay;
+}
+
+static fz_error
+loadsimilarcjkfont(pdf_fontdesc *font, int ros, int kind)
+{
+	switch (kind)
+	{
+	case MINCHO:
+		switch (ros)
+		{
+		case CNS: return pdf_loadsystemfont(font, "MingLiU", nil);
+		case GB: return pdf_loadsystemfont(font, "SimSun", nil);
+		case Japan: return pdf_loadsystemfont(font, "MS-Mincho", nil);
+		case Korea: return pdf_loadsystemfont(font, "Batang", nil);
+		}
+		break;
+	case GOTHIC:
+		switch (ros)
+		{
+		case CNS: return pdf_loadsystemfont(font, "DFKaiShu-SB-Estd-BF", nil);
+		case GB:
+			if (fz_okay == pdf_loadsystemfont(font, "KaiTi", nil))
+				return fz_okay;
+			return pdf_loadsystemfont(font, "KaiTi_GB2312", nil);
+		case Japan: return pdf_loadsystemfont(font, "MS-Gothic", nil);
+		case Korea: return pdf_loadsystemfont(font, "Gulim", nil);
+		}
+		break;
+	default:
+		return fz_throw("Unknown cid kind %d", kind);
+	}
+	return -1;
+}
+
+#if 0
+/* TODO: those rules conflict with pdf_loadsystemfont() logic. */
+static fz_error
+loadjapansubstitute(pdf_fontdesc *font, char *fontname)
+{
+	if (!strcmp(fontname, "GothicBBB-Medium"))
+		return loadwindowsfont(font, "MS-Gothic");
+
+	if (!strcmp(fontname, "Ryumin-Light"))
+		return loadwindowsfont(font, "MS-Mincho");
+
+	if (font->flags & FD_FIXED)
+	{
+		if (font->flags & FD_SERIF)
+			return loadwindowsfont(font, "MS-Mincho");
+
+		return loadwindowsfont(font, "MS-Gothic");
+	}
+
+	if (font->flags & FD_SERIF)
+			return loadwindowsfont(font, "MS-PMincho");
+
+	return loadwindowsfont(font, "MS-PGothic");
+}
+#endif
+
+/***** end of Windows font loading code *****/
+#endif
+
 fz_error
 pdf_loadbuiltinfont(pdf_fontdesc *fontdesc, char *fontname)
 {
 	fz_error error;
 	unsigned char *data;
 	unsigned int len;
 	int i;
 
 	for (i = 0; basefonts[i].name; i++)
 		if (!strcmp(fontname, basefonts[i].name))
 			goto found;
 
+#ifdef WIN32
+	/* we use built-in fonts in addition to those installed on windows
+	   because the metric for Times-Roman in windows fonts seems wrong
+	   and we end up with over-lapping text if this font is used.
+	   poppler doesn't have this problem even when using windows fonts
+	   so maybe there's a better fix. */
+	error = loadwindowsfont(fontdesc, fontname);
+	if (fz_okay == error)
+		return fz_okay;
+#endif
+
 	return fz_throw("cannot find font: '%s'", fontname);
 
 found:
 	pdf_logfont("load builtin font %s\n", fontname);
 
 	data = (unsigned char *) basefonts[i].cff;
 	len = *basefonts[i].len;
 
 	error = fz_newfontfrombuffer(&fontdesc->font, data, len, 0);
 	if (error)
 		return fz_rethrow(error, "cannot load freetype font from buffer");
 
+	/* cf. http://bugs.ghostscript.com/show_bug.cgi?id=691119 */
+	if (!strcmp(fontname, "Symbol") || !strcmp(fontname, "ZapfDingbats"))
+	{
+		/* hack to prevent StandardEncoding from being loaded in pdf_font.c */
+		fontdesc->isembedded = 1;
+		fontdesc->flags |= FD_SYMBOLIC;
+	}
 	fz_strlcpy(fontdesc->font->name, fontname, sizeof fontdesc->font->name);
 
 	return fz_okay;
 }
 
 static fz_error
 loadsystemcidfont(pdf_fontdesc *fontdesc, int ros, int kind)
 {
-#ifndef NOCJK
+#if !defined(NOCJK) && !defined(NOCJKFONT)
 	fz_error error;
+#endif
+#ifdef WIN32
+	/* Try to fall back to a reasonable TrueType font that might be installed locally */
+	if (loadsimilarcjkfont(fontdesc, ros, kind) == fz_okay)
+	{
+		fontdesc->font->ftsubstitute = 1;
+		return fz_okay;
+	}
+#ifdef NOCJKFONT
+	/* If no CJK fallback font is builtin, maybe one has been shipped separately */
+	if (loadwindowsfont(fontdesc, "DroidSansFallback") == fz_okay)
+	{
+		fontdesc->font->ftsubstitute = 1;
+		return fz_okay;
+	}
+#endif
+#endif
+#if !defined(NOCJK) && !defined(NOCJKFONT)
 	/* We only have one builtin fallback font, we'd really like
 	 * to have one for each combination of ROS and Kind.
 	 */
 	pdf_logfont("loading builtin CJK font\n");
 	error = fz_newfontfrombuffer(&fontdesc->font,
 		(unsigned char *)pdf_font_DroidSansFallback_ttf_buf,
 		pdf_font_DroidSansFallback_ttf_len, 0);
 	if (error)
@@ -164,16 +825,28 @@ pdf_loadsystemfont(pdf_fontdesc *fontdes
 	char *name;
 
 	int isbold = 0;
 	int isitalic = 0;
 	int isserif = 0;
 	int isscript = 0;
 	int isfixed = 0;
 
+#ifdef WIN32
+	/* try to find a precise match in Windows' fonts before falling back to a built-in one */
+	error = loadwindowsfont(fontdesc, fontname);
+	if (fz_okay == error)
+	{
+		/* TODO: this seems to be required at least for MS-Mincho - why? */
+		if (collection)
+			fontdesc->font->ftsubstitute = 1;
+		return fz_okay;
+	}
+#endif
+
 	if (strstr(fontname, "Bold"))
 		isbold = 1;
 	if (strstr(fontname, "Italic"))
 		isitalic = 1;
 	if (strstr(fontname, "Oblique"))
 		isitalic = 1;
 
 	if (fontdesc->flags & FD_FIXED)
diff -r 27dbba5ea9e6 mupdf/pdf_function.c
--- a/mupdf/pdf_function.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_function.c	Sat May 01 23:42:01 2010 +0200
@@ -461,16 +461,19 @@ loadpostscriptfunc(pdf_function *func, p
 	int codeptr;
 
 	pdf_logrsrc("load postscript function (%d %d R)\n", oid, gen);
 
 	error = pdf_openstream(&stream, xref, oid, gen);
 	if (error)
 		return fz_rethrow(error, "cannot open calculator function stream");
 
+	/* cf. http://bugs.ghostscript.com/show_bug.cgi?id=691139 */
+	while (fz_peekbyte(stream) == ' ') fz_readbyte(stream);
+
 	if (fz_readbyte(stream) != '{')
 	{
 		fz_dropstream(stream);
 		return fz_throw("stream is not a calculator function");
 	}
 
 	func->u.p.code = nil;
 	func->u.p.cap = 0;
diff -r 27dbba5ea9e6 mupdf/pdf_image.c
--- a/mupdf/pdf_image.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_image.c	Sat May 01 23:42:01 2010 +0200
@@ -524,16 +524,22 @@ pdf_loadtile(pdf_image *src, fz_pixmap *
 		case 2: bpcfact = 85; break;
 		case 4: bpcfact = 17; break;
 		case 8: bpcfact = 1; break;
 		}
 
 		tilefunc(src->samples->rp + (tile->y * src->stride), src->stride,
 			tmp->samples, tmp->w,
 			tmp->w, tmp->h, 0);
+		{ /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=336 */
+			float decode[2];
+			decode[0] = src->decode[0] * bpcfact / 255;
+			decode[1] = src->decode[1] * bpcfact / 255;
+			fz_decodetile(tmp, 0, decode);
+		}
 
 		for (y = 0; y < tile->h; y++)
 		{
 			int dn = tile->n;
 			unsigned char *dst = tile->samples + y * tile->w * dn;
 			unsigned char *st = tmp->samples + y * tmp->w;
 			unsigned char *index = src->indexed->lookup;
 			int high = src->indexed->high;
diff -r 27dbba5ea9e6 mupdf/pdf_interpret.c
--- a/mupdf/pdf_interpret.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_interpret.c	Sat May 01 23:42:01 2010 +0200
@@ -221,23 +221,32 @@ pdf_runinlineimage(pdf_csi *csi, fz_obj 
 	char buf[256];
 	pdf_token_e tok;
 	int len;
 
 	error = pdf_loadinlineimage(&img, csi->xref, rdb, dict, file);
 	if (error)
 		return fz_rethrow(error, "cannot load inline image");
 
+FindEndImageMarker:
 	error = pdf_lex(&tok, file, buf, sizeof buf, &len);
 	if (error)
 	{
 		pdf_dropimage(img);
 		return fz_rethrow(error, "syntax error after inline image");
 	}
 
+	/* apparently Adobe Reader silently ignores trailing garbage */
+	/* (this might even still be too conservative in what we tolerate) */
+	if (tok == PDF_TKEYWORD && strcmp("EI", buf))
+	{
+		fz_warn("ignoring garbage after inline image");
+		goto FindEndImageMarker;
+	}
+
 	if (tok != PDF_TKEYWORD || strcmp("EI", buf))
 	{
 		pdf_dropimage(img);
 		return fz_throw("syntax error after inline image");
 	}
 
 	pdf_showimage(csi, img);
 
@@ -770,16 +779,19 @@ Lsetcolor:
 			if (csi->top != 2)
 				goto syntaxerror;
 
 			dict = fz_dictgets(rdb, "Font");
 			if (!dict)
 				return fz_throw("cannot find Font dictionary");
 
 			obj = fz_dictget(dict, csi->stack[0]);
+			/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=424 */
+			if (!obj && dict->u.d.len > 0)
+				obj = dict->u.d.items[0].v; // Just fall back to any font, so that we can go on
 			if (!obj)
 				return fz_throw("cannot find font resource: %s", fz_toname(csi->stack[0]));
 
 			if (gstate->font)
 			{
 				pdf_dropfont(gstate->font);
 				gstate->font = nil;
 			}
@@ -1248,16 +1260,25 @@ pdf_runcsifile(pdf_csi *csi, fz_obj *rdb
 				obj = fz_newstring(buf, len);
 				fz_arraypush(csi->array, obj);
 				fz_dropobj(obj);
 			}
 			else if (tok == PDF_TEOF)
 			{
 				return fz_okay;
 			}
+			else if (tok == PDF_TKEYWORD && (!strcmp(buf, "Tc") || !strcmp(buf, "Tw")) && fz_arraylen(csi->array) > 0)
+			{
+				/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=916  */
+				/* According to the PDF reference, only strings and numbers are  */
+				/* allowed inside TJ array arguments; nonetheless some producers */
+				/* seem to include Tc and Tw commands inside them. Ignore these  */
+				/* for now (and consider respecting them for later).             */
+				fz_dropobj(csi->array->u.a.items[--csi->array->u.a.len]);
+			}
 			else
 			{
 				pdf_clearstack(csi);
 				return fz_throw("syntaxerror in array");
 			}
 		}
 
 		else switch (tok)
diff -r 27dbba5ea9e6 mupdf/pdf_lex.c
--- a/mupdf/pdf_lex.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_lex.c	Sat May 01 23:42:01 2010 +0200
@@ -221,17 +221,18 @@ lexhexstring(fz_stream *f, char *buf, in
 			}
 			else
 			{
 				a = fromhex(c);
 				x = !x;
 			}
 		}
 		else
-			break;
+			// cf. http://code.google.com/p/sumatrapdf/issues/detail?id=624
+			fz_warn("Ignoring invalid character in hexstring: %c", c);
 	}
 
 	return s - buf;
 }
 
 static pdf_token_e
 pdf_tokenfromkeyword(char *key)
 {
diff -r 27dbba5ea9e6 mupdf/pdf_open.c
--- a/mupdf/pdf_open.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_open.c	Sat May 01 23:42:01 2010 +0200
@@ -43,24 +43,35 @@ pdf_readstartxref(pdf_xref *xref)
 	int t, n;
 	int i;
 
 	error = fz_seek(xref->file, 0, 2);
 	if (error)
 		return fz_rethrow(error, "cannot seek to end of file");
 
 	t = MAX(0, fz_tell(xref->file) - ((int)sizeof buf));
+LookForEOF:
 	error = fz_seek(xref->file, t, 0);
 	if (error)
 		return fz_rethrow(error, "cannot seek to offset %d", t);
 
 	error = fz_read(&n, xref->file, buf, sizeof buf);
 	if (error)
 		return fz_rethrow(error, "cannot read from file");
 
+	/* make sure that the buffer ends with "%%EOF" before looking for "startxref" */
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=719 */
+	for (i = n - 5; i >= 0 && memcmp(buf + i, "%%EOF", 5) != 0; i--);
+	if (i < n - 5 && t > 0)
+	{
+		t = MAX(0, (t + i + 5) - ((int)sizeof buf));
+		goto LookForEOF;
+	}
+	n = i;
+
 	for (i = n - 9; i >= 0; i--)
 	{
 		if (memcmp(buf + i, "startxref", 9) == 0)
 		{
 			i += 9;
 			while (iswhite(buf[i]) && i < n)
 				i ++;
 			xref->startxref = atoi((char*)(buf + i));
@@ -77,28 +88,36 @@ pdf_readstartxref(pdf_xref *xref)
 
 static fz_error
 pdf_readoldtrailer(pdf_xref *xref, char *buf, int cap)
 {
 	fz_error error;
 	int ofs, len;
 	char *s;
 	int n;
-	int t;
 	pdf_token_e tok;
 	int c;
 
 	pdf_logxref("load old xref format trailer\n");
 
 	error = fz_readline(xref->file, buf, cap);
 	if (error)
 		return fz_rethrow(error, "cannot read xref marker");
 	if (strncmp(buf, "xref", 4) != 0)
 		return fz_throw("cannot find xref marker");
 
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=543 */
+	/* broken pdfs where 'ofs len' is not on a separate line */
+	if (strlen(buf) != 4)
+	{
+		error = fz_seek(xref->file, 4 - strlen(buf), 1);
+		if (error)
+			return fz_rethrow(error, "cannot seek in file");
+	}
+
 	while (1)
 	{
 		c = fz_peekbyte(xref->file);
 		if (!(c >= '0' && c <= '9'))
 			break;
 
 		error = fz_readline(xref->file, buf, cap);
 		if (error)
@@ -113,21 +132,18 @@ pdf_readoldtrailer(pdf_xref *xref, char 
 		/* broken pdfs where the section is not on a separate line */
 		if (s && *s != '\0')
 		{
 			error = fz_seek(xref->file, -(2 + strlen(s)), 1);
 			if (error)
 				return fz_rethrow(error, "cannot seek in file");
 		}
 
-		t = fz_tell(xref->file);
-		if (t < 0)
-			return fz_throw("cannot tell in file");
-
-		error = fz_seek(xref->file, t + 20 * len, 0);
+		/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=543 */
+		error = fz_seek(xref->file, 20 * len, 1);
 		if (error)
 			return fz_rethrow(error, "cannot seek in file");
 	}
 
 	error = fz_readerror(xref->file);
 	if (error)
 		return fz_rethrow(error, "cannot read from file");
 
@@ -218,16 +234,25 @@ pdf_readoldxref(fz_obj **trailerp, pdf_x
 	pdf_logxref("load old xref format\n");
 
 	error = fz_readline(xref->file, buf, cap);
 	if (error)
 		return fz_rethrow(error, "cannot read xref marker");
 	if (strncmp(buf, "xref", 4) != 0)
 		return fz_throw("cannot find xref marker");
 
+	/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=543 */
+	/* broken pdfs where 'ofs len' is not on a separate line */
+	if (strlen(buf) != 4)
+	{
+		error = fz_seek(xref->file, 4 - strlen(buf), 1);
+		if (error)
+			return fz_rethrow(error, "cannot seek in file");
+	}
+
 	while (1)
 	{
 		c = fz_peekbyte(xref->file);
 		if (!(c >= '0' && c <= '9'))
 			break;
 
 		error = fz_readline(xref->file, buf, cap);
 		if (error)
diff -r 27dbba5ea9e6 mupdf/pdf_repair.c
--- a/mupdf/pdf_repair.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_repair.c	Sat May 01 23:42:01 2010 +0200
@@ -52,18 +52,18 @@ fz_repairobj(fz_stream *file, char *buf,
 
 		obj = fz_dictgets(dict, "Length");
 		if (fz_isint(obj))
 			stmlen = fz_toint(obj);
 
 		obj = fz_dictgets(dict, "Filter");
 		if (fz_isname(obj) && !strcmp(fz_toname(obj), "Standard"))
 		{
-			fz_dropobj(dict);
-			return fz_throw("cannot repair encrypted files");
+			/* http://code.google.com/p/sumatrapdf/issues/detail?id=817 */
+			fz_warn("might not be able to repair encrypted files");
 		}
 
 		fz_dropobj(dict);
 	}
 
 	while ( tok != PDF_TSTREAM &&
 		tok != PDF_TENDOBJ &&
 		tok != PDF_TERROR &&
diff -r 27dbba5ea9e6 mupdf/pdf_unicode.c
--- a/mupdf/pdf_unicode.c	Sat May 01 14:31:12 2010 +0200
+++ b/mupdf/pdf_unicode.c	Sat May 01 23:42:01 2010 +0200
@@ -23,28 +23,40 @@ pdf_loadtounicode(pdf_fontdesc *font, pd
 		if (error)
 			return fz_rethrow(error, "cannot load embedded cmap");
 
 		font->tounicode = pdf_newcmap();
 
 		for (i = 0; i < (strings ? 256 : 65536); i++)
 		{
 			cid = pdf_lookupcmap(font->encoding, i);
-			if (cid > 0)
+			if (cid >= 0) /* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=687 */
 			{
 				ucs = pdf_lookupcmap(cmap, i);
 				if (ucs > 0)
 					pdf_maprangetorange(font->tounicode, cid, cid, ucs);
+				else if (ucs < -1)
+				{
+					/* cf. http://code.google.com/p/sumatrapdf/issues/detail?id=788 */
+					/* copy over a multi-character mapping */
+					int j, tbl[7], len = cmap->table[-ucs - 2];
+					if (len > 7) {
+						len = 7;
+					}
+					for (j = 0; j < len; j++)
+						tbl[j] = cmap->table[-ucs - 1 + j];
+					pdf_maponetomany(font->tounicode, cid, tbl, len);
+				}
 			}
 		}
 
 		pdf_sortcmap(font->tounicode);
 
 		pdf_dropcmap(cmap);
-		return fz_okay;
+		// return fz_okay; // cf. http://code.google.com/p/sumatrapdf/issues/detail?id=787
 	}
 
 	else if (collection)
 	{
 		pdf_logfont("tounicode cid collection (%s)\n", collection);
 
 		error = fz_okay;
 
